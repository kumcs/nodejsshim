--DO NOT EDIT THIS FILE! This file is generated by running the 'npm run build' command from this repos root. 
SELECT nodejsshim.npm_install('nodejsshim'::text, 'net'::text, '1.0.1'::text, 'https://github.com/xtuple/qt-script-node-js-shims'::text, $code_body$ 
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var Socket = require('./socket.qtscript');

/**
 * Emulate Node.js's net.Server class using Qt's QTcpServer class.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_class_net_server
 *
 * @param {Object} [options] - The socket connection options.
 * @param {Function} [connectionListener] - The connection callback.
 */
var Server = function serverConstructor (options, connectionListener) {
  if (!(this instanceof Server)) {
    return new Server(options, connectionListener);
  }

  EventEmitter.call(this);

  var self = this;

  if (typeof options === 'function') {
    connectionListener = options;
    options = {};
    self.on('connection', connectionListener);
  } else {
    options = options || {};

    if (typeof connectionListener === 'function') {
      self.on('connection', connectionListener);
    }
  }

  this._connections = 0

  this._handle = null;
  this._usingSlaves = false;
  this._slaves = [];
  this._unref = false;

  this.allowHalfOpen = options.allowHalfOpen || false;
  this.pauseOnConnect = !!options.pauseOnConnect;

  this.QTcpServer = new QTcpServer(mywindow);

  function _onConnection () {
    var connectionBeforeData = false;

    function emitConnection (data) {
      self.emit('connection', socket);

      if (data) {
        process.nextTick(function () {
          socket.emit('data', data);
        }, self);
      }
    }

    var tcpSocket = self.QTcpServer.nextPendingConnection();

    // We can't call tcpSocket.error() because it conflicts with the error signal exposure in Qt Script.
    if (tcpSocket.errorString() !== 'Unknown error') { // 'Unknown error' is what is returned when there is no error.
      self.emit('error', new Error(tcpSocket.errorString() + ' accept'));
      return;
    }

    if (self.maxConnections && self._connections >= self.maxConnections) {
      tcpSocket.abort();
      return;
    }

    var socket = new Socket({
      QTcpSocket: tcpSocket,
      allowHalfOpen: self.allowHalfOpen,
      pauseOnCreate: self.pauseOnConnect
    });
    socket.readable = socket.writable = true;

    // Sometimes the socket will emit 'data' before we emit `connection` below.
    // Add our own socket.on('data') handler that will emit `connection` first.
    socket.on('data', function (data) {
      if (!connectionBeforeData) {
        connectionBeforeData = true;
        emitConnection(data);
      }
    });

    self._connections++;
    socket.server = self;
    socket._server = self;

    process.nextTick(function () {
      if (!connectionBeforeData) {
        connectionBeforeData = true;
        emitConnection();
      }
    }, self);
  }

  this.QTcpServer["newConnection()"].connect(_onConnection);
};

util.inherits(Server, EventEmitter);

function isLegalPort(port) {
  return (port >= 0 && port < 65536);
}

function isPipeName(s) {
  return typeof s === 'string' && toNumber(s) === false;
}

function toNumber(x) {
  return (x = Number(x)) >= 0 ? x : false;
}

/**
 * @typedef ServerAddress
 * @type Object
 * @property port {Number} - The port the server is listening on.
 * @property family {String} - The IP address version.
 * @property address {String} - The IP address the server is listening on.
 */

/**
 * Emulate Node.js's `server.address()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_address
 *
 * @return {ServerAddress}
 */
Server.prototype.address = function address () {
  return {
    address: this.QTcpServer.serverAddress().toString(),
    family: this.QTcpServer.serverAddress().protocol() === 1 ? 'IPv6' : 'IPv4',
    port: this.QTcpServer.serverPort()
  };
};

/**
 * Emulate Node.js's `server.close([callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_close_callback
 *
 * @param {Function} [callback] - The callback to call when the server is closed.
 */
Server.prototype.close = function close (callback) {
  var self = this;
  this.QTcpServer.close();

  if (typeof callback === 'function') {
    if (!this.QTcpServer.isListening()) {
      this.once('close', function() {
        callback(new Error('Not running'));
      });
    } else {
      this.once('close', callback);
    }
  }

  process.nextTick(function () {
    self.emit('close');
  }, self);

  return this;
};

/**
 * Emulate Node.js's `server.getConnections(callback)` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_getconnections_callback
 *
 * @param {Function} [callback] - The callback to call with the number of connections.
 */
Server.prototype.getConnections = function getConnections (callback) {
  callback(null, this.QTcpServer._connections);
};

/**
 * Private helper function for `server.listen()`.
 *
 * @param {Object} self - The `Server` object.
 * @param {String} [address] - The address to listen on.
 * @param {Number} [port] - The port to listen on.
 * @param {Number} [addressType] - The IP address type, IPv4 === 4, IPv6 === 6.
 * @param {Number} [backlog] - The max pending connections to allow.
 */
function _listen(self, address, port, addressType, backlog) {
  if (backlog > 0) {
    self.QTcpServer.setMaxPendingConnections(backlog);
    self.maxConnections = backlog;
  }

  var hostAddress = new QHostAddress(address);

  if (!self.QTcpServer.listen(hostAddress, port)) {
    var message = "An unidentified error occurred when start to listen for the QTcpServer.";
    if (self.QTcpServer.serverError() > -1) {
      var message = self.QTcpServer.errorString();
    }

    var err = {
      message: message + " Server address:port: " + address + ":" + port
    };

    return self.emit('error', err);
  }

  // generate connection key, this should be unique to the connection
  self._connectionKey = addressType + ':' + address + ':' + port;

  process.nextTick(function () {
    self.emit('listening');
  }, self);
}

/**
 * Emulate Node.js's
 * `server.listen(handle[, backlog][, callback])`,
 * `server.listen(options[, callback])`,
 * `server.listen(path[, backlog][, callback])`,
 * `server.listen(port[, hostname][, backlog][, callback])` methods.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_handle_backlog_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_options_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_path_backlog_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_port_hostname_backlog_callback
 *
 * @param {Object | Number} - The config optoins | port to listen on.
 * @param {String | Function | Number} - The hostname to listen on | listen callback | max pending connections to allow.
 * @param {Function | Number} - The listen callback | max pending connections to allow.
 * @param {Function} - The listen callback.
 */
Server.prototype.listen = function listen () {
  var self = this;

  var lastArg = arguments[arguments.length - 1];
  if (typeof lastArg === 'function') {
    self.once('listening', lastArg);
  }

  var port = toNumber(arguments[0]);

  // The third optional argument is the backlog size.
  // When the ip is omitted it can be the second argument.
  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);

  if (arguments.length === 0 || typeof arguments[0] === 'function') {
    // Bind to a random port.
    _listen(self, null, 0, null, backlog);
  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {
    var h = arguments[0];
    h = h._handle || h.handle || h;

    if (h instanceof Server || h instanceof Socket) {
      //self._handle = h;
      //_listen(self, null, -1, -1, backlog);
      throw new Error('Server.listen on an existing Server or Socket argument is not supported.');
    } else if (typeof h.fd === 'number' && h.fd >= 0) {
      //_listen(self, null, null, null, backlog, h.fd);
      // TODO: This could be implimented with QFileDevice.
      throw new Error('Server.listen on an file discripter argument is not supported.');
    } else {
      // The first argument is a configuration object
      if (h.backlog)
        backlog = h.backlog;

      if (typeof h.port === 'number' || typeof h.port === 'string' ||
          (typeof h.port === 'undefined' && 'port' in h)) {
        // Undefined is interpreted as zero (random port) for consistency
        // with net.connect().
        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))
          throw new RangeError('port should be >= 0 and < 65536: ' + h.port);
        if (h.host)
          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);
        else
          _listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);
      } else if (h.path && isPipeName(h.path)) {
        //var pipeName = self._pipeName = h.path;
        //_listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);
        // TODO: This could be implimented with QFileDevice or QLocalSocket.
        throw new Error('Local path socket server is not supported.');
      } else {
        throw new Error('Invalid listen argument: ' + h);
      }
    }
  } else if (isPipeName(arguments[0])) {
    // UNIX socket or Windows pipe.
    //var pipeName = self._pipeName = arguments[0];
    //_listen(self, pipeName, -1, -1, backlog);
    // TODO: This could be implimented with QFileDevice or QLocalSocket.
    throw new Error('Local path socket server is not supported.');
  } else if (arguments[1] === undefined ||
             typeof arguments[1] === 'function' ||
             typeof arguments[1] === 'number') {
    // The first argument is the port, no IP given.
    _listen(self, null, port, 4, backlog);

  } else {
    // The first argument is the port, the second an IP.
    listenAfterLookup(port, arguments[1], backlog);
  }

  function listenAfterLookup(port, address, backlog, exclusive) {
    if (address === 'localhost') {
      _listen(self, '127.0.0.1', port, 4, backlog, undefined, exclusive);
    } else if (address === '::1') {
      _listen(self, address, port, 6, backlog, undefined, exclusive);
    } else if (address === '127.0.0.1') {
      _listen(self, address, port, 4, backlog, undefined, exclusive);
    } else {
      require('dns').lookup(address, function(err, ip, addressType) {
        if (err) {
          self.emit('error', err);
        } else {
          addressType = ip ? addressType : 4;
          _listen(self, ip, port, addressType, backlog, undefined, exclusive);
        }
      });
    }
  }

  return self;
};

// TODO: Support this?
/**
 * Emulate Node.js's `server.ref()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_ref
 *
 * @return {Server}
 */
Server.prototype.ref = function unref () {
  console.warn("Server.prototype.ref() has not been implemented.");
  return this;
};

// TODO: Support this?
/**
 * Emulate Node.js's `server.unref()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_unref
 *
 * @return {Server}
 */
Server.prototype.unref = function unref () {
  console.warn("Server.prototype.unref() has not been implemented.");
  return this;
};

module.exports = Server;

},{"./socket.qtscript":2,"dns":undefined,"events":undefined,"util":undefined}],2:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var utils = require('./utils.qtscript');

/**
 * Emulate Node.js's net.Socket class using Qt's QTcpSocket class.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_class_net_socket
 *
 * @param {Object} [options] - The socket connection options.
 */
var Socket = function socketConstructor (options) {
  EventEmitter.call(this);
  this._options = {
    fd: null,
    allowHalfOpen: false,
    readable: false,
    writable: false
  };

  if (typeof options === 'number') {
    options = { fd: options }; // Legacy interface.
  } else if (options === undefined) {
    options = {};
  }

  this._options = Object.assign(this._options, options);

  this._hadError = false;
  this._handle = null;
  this._parent = null;
  this._host = null;

  this.remoteAddress = null;
  this.remoteFamily = null;
  this.remotePort = null;
  this.localAddress = null;
  this._localFamily = null;
  this.localPort = null;
  this.bufferSize = null;
  this.bytesRead = null;
  this.bytesWritten = null;
  this._connecting = false;
  this.readable = false;
  this.writable = false;
  this._encoding = null;
  this._timer = false;
  this._timeout = 60 * 1000;
  this._idleTime = Date.now() + this._timeout;

/*
debugger;
  if (options.handle) {
    this._handle = options.handle; // private
  } else {
    // these will be set once there is a connection
    this.readable = this.writable = false;
  }

  // if we have a handle, then start the flow of data into the
  // buffer.  if not, then this will happen when we connect
  if (this._handle && options.readable !== false) {
// TODO: Below is for node's Stream. Convert to QTcpSocket.
debugger;
    if (options.pauseOnCreate) {
      // stop the handle from reading and pause the stream
      //this._handle.reading = false;
      //this._handle.readStop();
      //this._readableState.flowing = false;
    } else {
      //this.read(0);
    }
  }
*/

  if (options.QTcpSocket) {
    this.QTcpSocket = options.QTcpSocket;
  } else {
    this.QTcpSocket = new QTcpSocket(new QObject(mywindow));
  }
  // TODO: This just cuts it off at 1024. Figure out how to chunk the read.
  //this.QTcpSocket.setReadBufferSize(1024);
  var self = this;

  function _isConnected () {
    self._idleTime = Date.now() + self._timeout;
    self._connecting = false;
    self.readable = true;
    self.writable = true;
    self.localAddress = self.QTcpSocket.localAddress().toString();
    self.localPort = self.QTcpSocket.localPort();
    self.remoteAddress = self.QTcpSocket.peerAddress().toString();
    self.remotePort = self.QTcpSocket.peerPort();
    self.emit('connect');
  }
  function _isDisconnected () {
    self.emit('end');
    self.emit('close', false);
  }
  function _isError (socketError) {
    if (socketError === 1) {
      // This is just `QAbstractSocket::RemoteHostClosedError`, so ignore it.
      // The remote host closed the connection. Note that the client socket
      // (i.e., this socket) will be closed after the remote close notification
      // has been sent.
      // @See: https://doc.qt.io/qt-5/qabstractsocket.html#SocketError-enum
      return;
    }
    if (socketError === 5) {
      // TODO: `while (self.QTcpSocket.waitForReadyRead(200))` below throws signals error.
      // This probably happens if `waitForReadyRead()` calls `QTcpSocket.error()` to check for errors.
      // In Qt Script, there is a collision between the `error()` method and the signal.
      return;
    }
    self._idleTime = Date.now() + self._timeout;
    var err = {
      message: "enum QAbstractSocket::SocketError code: " + socketError
    };
    self.emit('error', err);
    self.emit('close', true);
  }
  function _isHostFound () {
    self._idleTime = Date.now() + self._timeout;
  }
  function _readData (loopedSize) {
    var size = self.QTcpSocket.bytesAvailable();
    if (size > 0) {
      self.isReading = true;
      self._idleTime = Date.now() + self._timeout;

      var qba = self.QTcpSocket.readAll();
      var data = utils._convertQByteArrayToEncoding(qba, self._encoding);
      self.emit('data', data);
      setTimeout(function () { _readData(size);}, 0);
    } else {
      self.isReading = false;
    }
  }
  function _isReadyRead () {
    if (!self.isReading) {
      _readData();
    }
  }
  function _isBytesWritten(bytes) {
    self._idleTime = Date.now() + self._timeout;
    self.bytesWritten = bytes;
    self.emit('drain');
  }

  this.QTcpSocket["connected()"].connect(_isConnected);
  this.QTcpSocket["disconnected()"].connect(_isDisconnected);
  this.QTcpSocket["error(QAbstractSocket::SocketError)"].connect(_isError);
  this.QTcpSocket["hostFound()"].connect(_isHostFound);
  this.QTcpSocket["readyRead()"].connect(_isReadyRead);
  this.QTcpSocket["bytesWritten(qint64)"].connect(_isBytesWritten);
};

util.inherits(Socket, EventEmitter);

Object.defineProperty(Socket.prototype, 'readyState', {
  get: function() {
    if (this._connecting) {
      return 'opening';
    } else if (this.readable && this.writable) {
      return 'open';
    } else if (this.readable && !this.writable) {
      return 'readOnly';
    } else if (!this.readable && this.writable) {
      return 'writeOnly';
    } else {
      return 'closed';
    }
  }
});

/**
 * Emulate Node.js's `socket.address()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_address
 *
 * @return {{address: {String}, port: {Number}, family: {String}}}
 */
Socket.prototype.address = function address () {
  return {
    address: this.localAddress,
    family: this._localFamily,
    port: this.localPort
  };
};

// Returns an array [options] or [options, cb]
// It is the same as the argument of Socket.prototype.connect().
function normalizeConnectArgs(args) {
  var options = {};

  if (args[0] !== null && typeof args[0] === 'object') {
    // connect(options, [cb])
    options = args[0];
  } else if (isPipeName(args[0])) {
    // connect(path, [cb]);
    options.path = args[0];
  } else {
    // connect(port, [host], [cb])
    options.port = args[0];
    if (typeof args[1] === 'string') {
      options.host = args[1];
    }
  }

  var cb = args[args.length - 1];
  return typeof cb === 'function' ? [options, cb] : [options];
}

/**
 * Emulate Node.js's `socket.connect(options[, connectListener])`,
 * `socket.connect(port[, host][, connectListener])`,
 * `socket.connect(path[, connectListener])` methods.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_connect_options_connectlistener
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_connect_path_connectlistener
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_connect_port_host_connectlistener
 *
 * @param {Object | Number | String} port - The connection's options|port|path.
 * @param {String | Function} [host] - The connections's host|connectionListener.
 * @param {Function} [connectListener] - The connections's connectionListener.
 */
Socket.prototype.connect = function connect (options, connectListener) {
  var self = this;

  if (options === null || typeof options !== 'object') {
    // Old API:
    // connect(port, [host], [cb])
    // connect(path, [cb]);
    var argsLen = arguments.length;
    var args = new Array(argsLen);
    for (var i = 0; i < argsLen; i++) {
      args[i] = arguments[i];
    }
    args = normalizeConnectArgs(args);
    return Socket.prototype.connect.apply(this, args);
  }

  var dns = require('dns');
  var dnsopts = {
    family: options.family || 4,
    hints: 0
  };
  self._host = options.host;
  var lookup = options.lookup || dns.lookup;

  this._connecting = true;
  this.writable = true;

  lookup(options.host, dnsopts, function(err, ip, addressType) {
    self.remoteAddress = ip;
    self.remoteFamily = addressType;
    self.remotePort = options.port;

    self.emit('lookup', err, ip, addressType);

    // It's possible we were destroyed while looking this up.
    // XXX it would be great if we could cancel the promise returned by
    // the look up.
    if (!self._connecting) return;

    if (err) {
      // net.createConnection() creates a net.Socket object and
      // immediately calls net.Socket.connect() on it (that's us).
      // There are no event listeners registered yet so defer the
      // error event to the next tick.
      err.host = options.host;
      err.port = options.port;
      err.message = err.message + ' ' + options.host + ':' + options.port;
      process.nextTick(function (self, err) {
        self.emit('error', err);
        self._destroy();
      }, self, err);
    } else {
      if (typeof connectListener === 'function') {
        self.on('connect', connectListener);
      }

      self.QTcpSocket.connectToHost(options.host, options.port);
    }
  });
};

/**
 * Emulate Node.js's `socket.destroy()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_destroy
 */
Socket.prototype.destroy = function destroy () {
  this.QTcpSocket.abort();
};

/**
 * Emulate Node.js's `socket.end([data][, encoding])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_end_data_encoding
 *
 * @param {String | Buffer} [data] - If set, passed to socket.write(data, encoding);
 * @param {String} [encoding] - If set, passed to socket.write(data, encoding);
 */
Socket.prototype.end = function end (data, encoding) {
  var self = this;
  if (data) {
    this.write(data, encoding);
    this.on('drain', function () {
      self.QTcpSocket.disconnectFromHost();
    });
  } else {
    this.QTcpSocket.disconnectFromHost();
  }
};

/**
 * Emulate Node.js's `socket.pause()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_pause
 */
Socket.prototype.pause = function pause () {
  // We cannot support pausing the socket. Qt only allows for QAbstractSocket::PauseOnSslErrors.
  console.warn("socket.pause() is not supported by Qt's QAbstractSocket.")
};

// TODO: Support this?
/**
 * Emulate Node.js's `socket.ref()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_ref
 *
 * @return {Socket}
 */
Socket.prototype.ref = function ref () {
  console.warn("Socket.prototype.ref() has not been implemented.");
  return this;
};

/**
 * Emulate Node.js's `socket.resume()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_resume
 */
Socket.prototype.resume = function resume () {
  this.QTcpSocket.resume();
};

/**
 * Emulate Node.js's `socket.setEncoding([encoding])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_setencoding_encoding
 *
 * @param {String} [encoding] - The encoding for the socket.
 */
Socket.prototype.setEncoding = function setEncoding (encoding) {
  if (encoding) {
    this._encoding = encoding;
  } else {
    // Reset.
    this._encoding = null;
  }
};

/**
 * Emulate Node.js's `socket.setKeepAlive([enable][, initialDelay])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_setkeepalive_enable_initialdelay
 *
 * @param {Boolean} [enable] - Set to true to enable keepalive.
 * @param {Number} [initialDelay] - Not supported by Qt's QAbstractSocket.
 * @return {Socket}
 */
Socket.prototype.setKeepAlive = function setKeepAlive (enable, initialDelay) {
  if (typeof enable === 'undefined') {
    enable = false;
  }

  if (initialDelay) {
    console.warn("socket.setKeepAlive([enable][, initialDelay]). The `initialDelay` parameter is not supported by Qt's QAbstractSocket.")
  }

  this.QTcpSocket.setSocketOption(QAbstractSocket.KeepAliveOption, enable);

  return this;
};

/**
 * Emulate Node.js's `socket.setNoDelay([noDelay])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_setnodelay_nodelay
 *
 * @param {Boolean} [noDelay] - Set to true to enable keepalive.
 * @return {Socket}
 */
Socket.prototype.setNoDelay = function setNoDelay (noDelay) {
  if (typeof noDelay === 'undefined') {
    noDelay = true;
  }

  this.QTcpSocket.setSocketOption(QAbstractSocket.LowDelayOption, noDelay);

  return this;
};

/**
 * Emulate Node.js's `socket.setTimeout(timeout[, callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_settimeout_timeout_callback
 *
 * @param {Number} timeout - Sets the socket to timeout after timeout milliseconds
 *   of inactivity on the socket.
 * @param {Function} [callback] - The function to call when the idle timeout is reached.
 * @return {Socket}
 */
Socket.prototype.setTimeout = function setTimeout (timeout, callback) {
  var self = this;

  if (self._timer && timeout === 0) {
    clearInterval(self._timer);
  } else {
    if (callback) {
      self.once('timeout', callback);
    }
    self._timeout = timeout;
    self._idleTime = Date.now() + self._timeout;

    // Once a second, check if we hit the idle timeout.
    self._timer = setInterval(function () {
      if (self._idleTime < Date.now()) {
        self.emit('timeout');
      }
    }, 1000);
  }

  return this;
};

// TODO: Support this?
/**
 * Emulate Node.js's `socket.unref()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_unref
 *
 * @return {Socket}
 */
Socket.prototype.unref = function unref () {
  console.warn("Socket.prototype.unref() has not been implemented.");
  return this;
};

/**
 * Emulate Node.js's `socket.write(data[, encoding][, callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_socket_write_data_encoding_callback
 *
 * @param {String | Buffer} [data] - The data to write to the socket.
 * @param {String | Function} [encoding] - The encoding for the data.
 * @param {Function} [callback] - Callback will be executed when the data is
 *   finally written out - this may not be immediately.
 */
Socket.prototype.write = function write (data, encoding, callback) {
  var next;
  var writeEncoding;
  if (typeof encoding === 'function' && typeof callback === 'undefined') {
    next = encoding;
  } else {
    writeEncoding = encoding;
    next = callback;
  }

  if (typeof next === 'function') {
    this.on('drain', next);
  }

  var qba = utils._convertEncodingToQByteArray(data, writeEncoding);
  var written = this.QTcpSocket.write(qba);

  return 0 < written;
};

module.exports = Socket;

},{"./utils.qtscript":3,"dns":undefined,"events":undefined,"util":undefined}],3:[function(require,module,exports){
/**
 * Helper function to convert the hash's encoded data to a Qt QByteArray.
 *
 * @param {String | Buffer} data - The data to hash. If data is a Buffer then encoding is ignored.
 * @param {String} [encoding] - The encoding given can be 'utf8', 'ascii' or 'binary'.
 *   If no encoding is provided, and the input is a string, an encoding of 'binary' is enforced.
 * @return {QByteArray | Boolean} - A QByteArray of the data.
 * @private
 */
var _convertEncodingToQByteArray = function _convertEncodingToQByteArray (data, encoding) {
  var qba;
  if (Buffer.isBuffer(data)) {
    if (data.QByteArray) {
      //qba = new QByteArray(data.QByteArray);
      qba = data.QByteArray;
    } else {
      qba = new QByteArray(data.length, 0);
      var size = data.length;
      for (var i = 0; i < size; i++) {
        qba.replace(i, 1, QByteArray(1, data[i]));
      }
    }
  } else {
    switch (encoding) {
      // TODO: Do we need to do any conversion?
      case 'ascii':
      case 'binary':
      case 'utf8':
        qba = new QByteArray(data);
        break;
      default:
        if (typeof data === 'string') {
          // Node.js's default is 'binary'.
          qba = _convertEncodingToQByteArray (data, 'binary')
        } else {
          return false;
        }
    }
  }

  return qba;
};

/**
 * Helper function to convert a Qt QByteArray to the encoding format.
 *
 * @param {QByteArray} qba - The QByteArray to convert.
 * @param {String} [encoding] - The encoding can be 'hex', 'binary' or 'base64'.
 *   If no encoding is provided, then a buffer is returned.
 * @return {String | Buffer} - The encoded QByteArray data.
 * @private
 */
var _convertQByteArrayToEncoding = function _convertQByteArrayToEncoding (qba, encoding) {
  var data;
  switch (encoding) {
    case 'base64':
      data = qba.toBase64();
      break;
    case 'binary':
      data = qba.toString();
      break;
    case 'hex':
      data = qba.toHex();
      break;
    case 'utf8':
    case 'utf-8':
    default:
      // Utf8 encode the QByteArray.
      //var encodedQba = new QByteArray(qba.toString());
      var encodedQba = new QByteArray(qba.toLatin1());

      // Node.js's default is a Buffer.
      if (Buffer.fromQByteArray) {
        data = Buffer.fromQByteArray(encodedQba);
      } else {
        var buffer = new Buffer(encodedQba.size());
        var mask = (1 << 8) -1;
        // HEX conversion is slower.
        //var hex = encodedQba.toHex().toString();
        //buffer.write(hex, "hex");
        var size = encodedQba.size();
        for (var i = 0; i < size; i++) {
          buffer[i] = encodedQba.at(i) & mask;
        }
        data = buffer;
      }
  }

  return data;
};

/**
 * Helper function to get the IP protocol.
 *
 * @param {Number} [input] - The address to get the IP protocol for.
 * @return {String | Boolean} - The IP protocol or false.
 * @private
 */
var _getIpProtocol = function _getIpProtocol (input) {
  var address = new QHostAddress(input);

  if (address.isNull()) {
    return false;
  } else {
    return _mapIpProtocol(address.protocol());
  }
};

/**
 * Helper function to get the IP protocol.
 *
 * @param {Number} networkLayerProtocol - The `enum QAbstractSocket::NetworkLayerProtocol` integer.
 * @return {String} - The IP protocol.
 * @private
 */
var _mapIpProtocol = function _mapIpProtocol (networkLayerProtocol) {
  switch (networkLayerProtocol) {
    case 0:
      return 'IPv4';
    case 1:
      return 'IPv6';
    default:
      return null;
  }
};

module.exports = {
  _convertEncodingToQByteArray: _convertEncodingToQByteArray,
  _convertQByteArrayToEncoding: _convertQByteArrayToEncoding,
  _getIpProtocol: _getIpProtocol,
  _mapIpProtocol: _mapIpProtocol
};

},{}],"net":[function(require,module,exports){
var Server = require('./server.qtscript');
var Socket = require('./socket.qtscript');
var utils = require('./utils.qtscript');

var net = {

  /**
   * Emulate Node.js's `net.createServer([options][, connectionListener])` method.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createserver_options_connectionlistener
   *
   * @param {Object} [options] - The server options.
   * @param {Function} [connectionListener] - Automatically set as a listener for
   *   the 'connection' event.
   * @return {Server} - The new Server object.
   */
  createServer: function createServer (options, connectionListener) {
    var server = new Server(options, connectionListener);

    return server;
  },

  /**
   * Overload of `net.createConnection()` to emulate Node.js's
   * `net.connect(options[, connectListener])`,
   * `net.connect(port[, host][, connectListener])`,
   * `net.connect(path[, connectListener])` methods.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_options_connectlistener
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_path_connectlistener
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_port_host_connectlistener
   */
  connect: this.createConnection,

  /**
   * Emulate Node.js's `net.createConnection(options[, connectListener])`,
   * `net.createConnection(port[, host][, connectListener])`,
   * `net.createConnection(path[, connectListener])` methods.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_options_connectlistener
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_path_connectlistener
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createconnection_port_host_connectlistener
   *
   * @param {Object | Number | String} port - The connection's options|port|path.
   * @param {String | Function} [host] - The connections's host|connectionListener.
   * @param {Function} [connectListener] - The connections's connectionListener.
   * @return {Socket} - The new Socket object.
   */
  createConnection: function createConnection (port, host, connectListener) {
    var options = (typeof port === 'object') ? port : false;
    var listener = (typeof host === 'function') ? host : connectListener;
    var path = (port !== parseInt(port, 10)) ? port : false;

    // If host is omitted, 'localhost' will be assumed when using port.
    host = (!host && !options && !path) ? 'localhost' : host;

    if (!options) {
      options = {};
      if (port && !path) {
        options.port = port;
      }
      if (host && !path) {
        options.host = host;
      }
      if (path) {
        options.path = path;
      }
      // TODO: Do we need to set `localAddress`, `localPort`, `family`, `lookup`?
    }

    var socket = new Socket(options);
    socket.connect(options, listener);
    return socket;
  },

  /**
   * Emulate Node.js's `net.isIP(input)` method.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_isip_input
   *
   * Tests if input is an IP address. Returns 0 for invalid strings, returns 4
   * for IP version 4 addresses, and returns 6 for IP version 6 addresses.
   *
   * @param {String} input - The address string to check.
   * @return {Number} - Returns 0 for invalid strings, returns 4 for IP version 4
   *   addresses, and returns 6 for IP version 6 addresses.
   */
  isIP: function isIP (input) {
    var networkLayerProtocol = utils._getIpProtocol(input);

    if (!networkLayerProtocol) {
      return 0;
    } else if (networkLayerProtocol === 'IPv4') {
      return 4;
    } else if (networkLayerProtocol === 'IPv6') {
      return 6;
    }
  },

  /**
   * Emulate Node.js's `net.isIPv4(input)` method.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_isipv4_input
   *
   * Tests if input is an IP address.
   *
   * @param {String} input - The address string to check.
   * @return {boolean} - Returns true if input is a version 4 IP address,
   *   otherwise returns false.
   */
  isIPv4: function isIPv4 (input) {
    return utils._getIpProtocol(input);
  },

  /**
   * Emulate Node.js's `net.isIPv6(input)` method.
   * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_isipv6_input
   *
   * Tests if input is an IP address.
   *
   * @param {String} input - The address string to check.
   * @return {boolean} - Returns true if input is a version 6 IP address,
   *   otherwise returns false.
   */
  isIPv6: function isIPv6 (input) {
    return utils._getIpProtocol(input);
  },

  Server: Server,
  Socket: Socket,
  Stream: Socket // Older Node.js APIs use `Stream` instead of `Socket`.
};

module.exports = net;

},{"./server.qtscript":1,"./socket.qtscript":2,"./utils.qtscript":3}]},{},[]); 
$code_body$::text); 
